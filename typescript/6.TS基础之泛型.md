泛型大大增加了代码的复用，使用者根据自己的类型需求去消费。

我们使用类型变量来定义泛型，一种类型而非值的特殊变量。

```ts
function identity<T>(arg: T): T {
  return arg;
}
let value = identity<string>("hello");
let min = identity(100);
```

这里我们使用 `T` 来表示这个类型变量。

我们在消费的时候，简单的我们可以使用类型参数推断来自动帮助我们推到类型。

```ts
function identity<T>(arg: T): T {
  const length = arg.length; // 类型“T”上不存在属性“length”。
  return arg;
}
```

在使用泛型的时候，我们必须认真对待我们的参数，在内部逻辑中，参数可以为任何类型的值，所以我们要约束或者兼容。

上面，我们可以使用泛型约束或者修改传入的参数类型使之具有 length 属性。
