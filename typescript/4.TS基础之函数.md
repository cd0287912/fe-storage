### 函数类型表达式

函数表达式类似于箭头函数。`(args: any) => void` 表示一个参数为 args 且类型为 any，没有返回值的函数。

```ts
function greeter(fn: (a: string) => void) {
  fn("hello world");
}
function print(str: string) {
  console.log(str);
}
greeter(print);
```

可以使用类型别名来定义一个函数类型。

```ts
type greetCallBack = (a: string) => void;

function greeter(fn: greetCallBack) {
  fn("hello world");
}
```

### 调用签名

有时候函数会有自己的属性。类型表达式并不能表达这样的情况，所以我们使用函数调用签名表示这种情况。

```ts
type DescriptFun = {
  desc: string;
  (key: number): boolean;
};

function doSomething(fn: DescriptFun) {
  console.log(fn.desc + " returned " + fn(1));
}
```

注意:函数签名时，函数体的表达和函数表达式是有区别的。

### 构造签名

js 函数是可以用 `new` 调用的，使用 `new` 调用时函数默认为构造函数，会生成新的对象。可以写一个构造签名。

```ts
interface Person {
  name: string;
  age: number;
}

type PersonConstructor = {
  new (): Person;
};

function generatePerson(ctor: PersonConstructor) {
  return new ctor();
}
```

### 泛型函数

约束函数参数与参数，参数与返回值的关系，可以使用泛型。

```ts
function firstEle<T>(array: T[]): T {
  return array[0];
}
// number
const result = firstEle([1, 2, 3]);
// string
const result2 = firstEle(["1", "2", "3"]);
```

```ts
function forMap<T, K>(array: T[], fun: (key: T) => K): K[] {
  return array.map(fun);
}
const result = forMap([1, 2, 3], (key) => {
  return key * 2;
});
```

```ts
function minimumLength<T extends { length: number }>(obj: T, min: number): T {
  if (obj.length >= min) {
    return obj;
  } else {
    return { ...obj, length: min };
  }
}
const result = minimumLength([1, 2, 3], 6);
console.log(result);
```

### 可选参数

一些函数的参数是可选的，那么我们可以使用 `?` 来表示参数是可选。

```ts
function f(x?: number) {}
```
