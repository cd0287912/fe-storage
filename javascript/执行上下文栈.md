### 执行上下文栈

```js
var foo = function () {
  console.log("foo1");
};
foo(); // foo1
var foo = function () {
  console.log("foo2");
};
foo(); // foo2
```

```js
function foo() {
  console.log("foo1");
}
foo(); // foo2
function foo() {
  console.log("foo2");
}
foo(); // foo2
```

JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。
那么这“一段一段”中的“段”究竟是怎么划分的呢？到底 JavaScript 引擎遇到一段怎样的代码时才会做“准备工作”呢？

### 可执行代码

js 中可执行代码为三种类型:

- 全局代码
- 函数代码
- eval 代码

每当 js 遇到这些代码的时候，就会做“准备工作”，我们叫做执行上下文。
代码中有很多执行上下文，js 如何管理呢? JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。默认都有 **globalContext** 全局上下文，并且在栈底。

模拟执行上下文栈:

```js
ECStack = [globalContext];
```

现在 JavaScript 遇到下面的这段代码了：

```js
function fun3() {
  console.log("fun3");
}

function fun2() {
  fun3();
}

function fun1() {
  fun2();
}

fun1();
```

当执行一个函数的时候，就会创建一个执行上下文，并且压入上下文栈中。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。

```js
// 执行fun1
ECStack.push(<fun1> fun1Context);       // [globalContext,fun1Context]

// 有fun1中有fun2,继续创建上下文并压栈
ECStack.push(<fun2> fun2Context);  // [globalContext,fun1Context,fun2Context]

// 有fun2中有fun3,继续创建上下文并压栈
ECStack.push(<fun3> fun3Context);  // [globalContext,fun1Context,fun2Context,fun3Context]

// fun3执行完毕
ECStack.pop();

// fun2执行完毕
ECStack.pop();

// fun1执行完毕
ECStack.pop();

...继续执行下面代码
```

### 执行上下文对象

在每个执行上下文创建的时候，都有三个重要的属性:

- **变量对象(Variable object，VO)**
- **作用域链(Scope chain)**
- **this**
